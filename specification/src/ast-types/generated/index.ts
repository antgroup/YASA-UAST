// NOTE: This file is autogenerated. Do not modify.

export interface SourceLocation {
  start: {
    line: number
    column: number
  }
  end: {
    line: number
    column: number
  }
  sourcefile?: string | null
}

interface BaseNode {
  type: Node['type']
  loc: SourceLocation | undefined
  _meta?: Record<string, unknown>
}

export type Node =
  | ArrayType
  | AssignmentExpression
  | BinaryExpression
  | BreakStatement
  | CallExpression
  | CaseClause
  | CastExpression
  | CatchClause
  | ChanType
  | ClassDefinition
  | CompileUnit
  | ConditionalExpression
  | ContinueStatement
  | DereferenceExpression
  | DynamicType
  | ExportStatement
  | ExpressionStatement
  | ForStatement
  | FuncType
  | FunctionDefinition
  | Identifier
  | IfStatement
  | ImportExpression
  | LabeledStatement
  | Literal
  | MapType
  | MemberAccess
  | NewExpression
  | Noop
  | ObjectExpression
  | ObjectProperty
  | PackageDeclaration
  | PointerType
  | PrimitiveType
  | RangeStatement
  | ReferenceExpression
  | ReturnStatement
  | ScopedStatement
  | ScopedType
  | Sequence
  | SliceExpression
  | SpreadElement
  | SuperExpression
  | SwitchStatement
  | ThisExpression
  | ThrowStatement
  | TryStatement
  | TupleExpression
  | TupleType
  | UnaryExpression
  | VariableDeclaration
  | VoidType
  | WhileStatement
  | YieldExpression

export interface Noop extends BaseNode {
  type: 'Noop'
}

export interface Literal extends BaseNode {
  type: 'Literal'
  value: null | number | string | boolean
  literalType: 'null' | 'number' | 'string' | 'boolean'
}

export interface Identifier extends BaseNode {
  type: 'Identifier'
  name: string
}

/**
一个最小的编译单元。例如一个.js或.py或.class文件，都是一个最小编译单元
**/
export interface CompileUnit extends BaseNode {
  type: 'CompileUnit'
  body: Array<Instruction>
  /**源语言种类**/
  language: 'javascript' | 'typescript' | 'java' | 'golang' | 'python'
  /**源语言版本**/
  languageVersion?: number | string | boolean | null
  /**该AST的唯一标识**/
  uri: string
  /**UAST版本**/
  version: string
}

export interface ExportStatement extends BaseNode {
  type: 'ExportStatement'
  argument: Expression
  alias: Identifier
}

export interface IfStatement extends BaseNode {
  type: 'IfStatement'
  test: Expression
  consequent: Instruction
  alternative?: Instruction | null
}

export interface SwitchStatement extends BaseNode {
  type: 'SwitchStatement'
  discriminant: Expression
  cases: Array<CaseClause>
}

export interface CaseClause extends BaseNode {
  type: 'CaseClause'
  test?: Expression | null
  body: Instruction
}

export interface ForStatement extends BaseNode {
  type: 'ForStatement'
  init?: Expression | VariableDeclaration | null
  test?: Expression | null
  update?: Expression | null
  body: Instruction
}

export interface WhileStatement extends BaseNode {
  type: 'WhileStatement'
  test: Expression
  body: Instruction
  isPostTest?: boolean | null
}

export interface RangeStatement extends BaseNode {
  type: 'RangeStatement'
  key?: VariableDeclaration | Expression | null
  value?: VariableDeclaration | Expression | null
  right: Expression
  body: Instruction
}

export interface LabeledStatement extends BaseNode {
  type: 'LabeledStatement'
  label?: Identifier | null
  body: Instruction
}

export interface ReturnStatement extends BaseNode {
  type: 'ReturnStatement'
  argument?: Expression | null
  isYield: boolean
}

export interface BreakStatement extends BaseNode {
  type: 'BreakStatement'
  label?: Identifier | null
}

export interface ContinueStatement extends BaseNode {
  type: 'ContinueStatement'
  label?: Identifier | null
}

export interface ThrowStatement extends BaseNode {
  type: 'ThrowStatement'
  argument?: Expression | null
}

export interface TryStatement extends BaseNode {
  type: 'TryStatement'
  body: Statement
  handlers?: Array<null | CatchClause> | null
  finalizer?: Instruction | null
}

export interface CatchClause extends BaseNode {
  type: 'CatchClause'
  parameter: Array<null | VariableDeclaration | Sequence>
  body: Instruction
}

export interface ExpressionStatement extends BaseNode {
  type: 'ExpressionStatement'
  expression: Expression
}

export interface ScopedStatement extends BaseNode {
  type: 'ScopedStatement'
  body: Array<Instruction>
  id?: Identifier | null
}

export interface BinaryExpression extends BaseNode {
  type: 'BinaryExpression'
  operator:
    | '+'
    | '-'
    | '*'
    | '/'
    | '**'
    | '%'
    | '<<'
    | '>>'
    | '>>>'
    | '<<<'
    | '&&'
    | '||'
    | ',,'
    | '&'
    | ','
    | '^'
    | '<'
    | '>'
    | '<='
    | '>='
    | '=='
    | '!='
    | '|'
    | 'instanceof'
    | 'in'
    | 'push'
    | '==='
    | '!=='
    | '??'
  left: Expression
  right: Expression
}

export interface UnaryExpression extends BaseNode {
  type: 'UnaryExpression'
  operator: '-' | '+' | '++' | '--' | '~' | 'delete' | '!' | 'typeof' | 'void'
  argument: Expression
  isSuffix?: boolean
}

export interface AssignmentExpression extends BaseNode {
  type: 'AssignmentExpression'
  left: LVal
  right: Expression
  operator:
    | '='
    | '^='
    | '&='
    | '<<='
    | '>>='
    | '>>>='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '|='
    | '**='
  cloned?: boolean | null
}

export interface Sequence extends BaseNode {
  type: 'Sequence'
  expressions: Array<Instruction>
}

export interface CastExpression extends BaseNode {
  type: 'CastExpression'
  expression: Expression
  as: Type
}

export interface ConditionalExpression extends BaseNode {
  type: 'ConditionalExpression'
  test: Expression
  consequent: Expression
  alternative: Expression
}

export interface SuperExpression extends BaseNode {
  type: 'SuperExpression'
}

export interface ThisExpression extends BaseNode {
  type: 'ThisExpression'
}

export interface MemberAccess extends BaseNode {
  type: 'MemberAccess'
  object: Expression
  property: Expression
  computed: boolean
}

export interface SliceExpression extends BaseNode {
  type: 'SliceExpression'
  start?: Instruction | null
  end?: Instruction | null
  step?: Instruction | null
}

export interface TupleExpression extends BaseNode {
  type: 'TupleExpression'
  elements: Array<Expression | Instruction>
  modifiable?: boolean | null
}

export interface ObjectExpression extends BaseNode {
  type: 'ObjectExpression'
  properties: Array<ObjectProperty | SpreadElement>
  id?: Identifier | null
}

export interface ObjectProperty extends BaseNode {
  type: 'ObjectProperty'
  key: Expression
  value: null | Expression
}

export interface CallExpression extends BaseNode {
  type: 'CallExpression'
  callee: Expression
  arguments: Array<null | Expression>
}

export interface NewExpression extends BaseNode {
  type: 'NewExpression'
  callee: Expression
  arguments: Array<Expression>
}

export interface FunctionDefinition extends BaseNode {
  type: 'FunctionDefinition'
  id?: Expression | null
  parameters: Array<null | VariableDeclaration>
  returnType: Type
  body: Instruction
  modifiers: Array<null | string>
}

export interface ClassDefinition extends BaseNode {
  type: 'ClassDefinition'
  id?: Identifier | null
  body: Array<null | Instruction>
  supers: Array<null | Expression>
}

export interface VariableDeclaration extends BaseNode {
  type: 'VariableDeclaration'
  id: Expression
  init?: Expression | null
  cloned?: boolean | null
  varType: Type
  variableParam?: boolean | null
}

export interface DereferenceExpression extends BaseNode {
  type: 'DereferenceExpression'
  argument: Expression
}

export interface ReferenceExpression extends BaseNode {
  type: 'ReferenceExpression'
  argument: Expression
}

export interface ImportExpression extends BaseNode {
  type: 'ImportExpression'
  from: Literal
  local?: Identifier | null
  imported?: Identifier | Literal | null
}

export interface SpreadElement extends BaseNode {
  type: 'SpreadElement'
  argument: Expression
}

export interface YieldExpression extends BaseNode {
  type: 'YieldExpression'
  argument?: Expression | null
}

export interface PackageDeclaration extends BaseNode {
  type: 'PackageDeclaration'
  name: Expression
}

export interface PrimitiveType extends BaseNode {
  type: 'PrimitiveType'
  id: Identifier
  typeArguments?: Array<Type> | null
  kind: 'string' | 'number' | 'boolean' | 'null'
}

export interface ArrayType extends BaseNode {
  type: 'ArrayType'
  id: Identifier
  element: Type
  typeArguments?: Array<Type> | null
  size?: Expression | null
}

export interface PointerType extends BaseNode {
  type: 'PointerType'
  id: Identifier
  element: Type
  typeArguments?: Array<Type> | null
  kind: 'pointer' | 'reference'
}

export interface MapType extends BaseNode {
  type: 'MapType'
  id: Identifier
  keyType: Type
  valueType: Type
  typeArguments?: Array<Type> | null
}

export interface ScopedType extends BaseNode {
  type: 'ScopedType'
  id: Identifier
  scope: null | Type
  typeArguments?: Array<Type> | null
}

export interface TupleType extends BaseNode {
  type: 'TupleType'
  id: Identifier
  elements: Array<Type>
  typeArguments?: Array<Type> | null
}

export interface ChanType extends BaseNode {
  type: 'ChanType'
  id: Identifier
  dir: string
  valueType: Type
}

export interface FuncType extends BaseNode {
  type: 'FuncType'
  id: Identifier
  typeParams: Array<Type>
  params: Array<Type>
  results: Array<Type>
}

export interface DynamicType extends BaseNode {
  type: 'DynamicType'
  id?: Identifier | null
  typeArguments?: Array<Type> | null
}

export interface VoidType extends BaseNode {
  type: 'VoidType'
  id?: Identifier | null
  typeArguments?: Array<Type> | null
}

export type Standardized =
  | Noop
  | Literal
  | Identifier
  | CompileUnit
  | ExportStatement
  | IfStatement
  | SwitchStatement
  | CaseClause
  | ForStatement
  | WhileStatement
  | RangeStatement
  | LabeledStatement
  | ReturnStatement
  | BreakStatement
  | ContinueStatement
  | ThrowStatement
  | TryStatement
  | CatchClause
  | ExpressionStatement
  | ScopedStatement
  | BinaryExpression
  | UnaryExpression
  | AssignmentExpression
  | Sequence
  | CastExpression
  | ConditionalExpression
  | SuperExpression
  | ThisExpression
  | MemberAccess
  | SliceExpression
  | TupleExpression
  | ObjectExpression
  | ObjectProperty
  | CallExpression
  | NewExpression
  | FunctionDefinition
  | ClassDefinition
  | VariableDeclaration
  | DereferenceExpression
  | ReferenceExpression
  | ImportExpression
  | SpreadElement
  | YieldExpression
  | PackageDeclaration
  | PrimitiveType
  | ArrayType
  | PointerType
  | MapType
  | ScopedType
  | TupleType
  | ChanType
  | FuncType
  | DynamicType
  | VoidType
export type Instruction =
  | Noop
  | Literal
  | Identifier
  | ExportStatement
  | IfStatement
  | SwitchStatement
  | ForStatement
  | WhileStatement
  | RangeStatement
  | LabeledStatement
  | ReturnStatement
  | BreakStatement
  | ContinueStatement
  | ThrowStatement
  | TryStatement
  | CatchClause
  | ExpressionStatement
  | ScopedStatement
  | BinaryExpression
  | UnaryExpression
  | AssignmentExpression
  | Sequence
  | CastExpression
  | ConditionalExpression
  | SuperExpression
  | ThisExpression
  | MemberAccess
  | SliceExpression
  | TupleExpression
  | ObjectExpression
  | ObjectProperty
  | CallExpression
  | NewExpression
  | FunctionDefinition
  | ClassDefinition
  | VariableDeclaration
  | DereferenceExpression
  | ReferenceExpression
  | ImportExpression
  | SpreadElement
  | YieldExpression
  | PackageDeclaration
export type Expression =
  | Noop
  | Literal
  | Identifier
  | SwitchStatement
  | ReturnStatement
  | BinaryExpression
  | UnaryExpression
  | AssignmentExpression
  | Sequence
  | CastExpression
  | ConditionalExpression
  | SuperExpression
  | ThisExpression
  | MemberAccess
  | SliceExpression
  | TupleExpression
  | ObjectExpression
  | ObjectProperty
  | CallExpression
  | NewExpression
  | FunctionDefinition
  | ClassDefinition
  | VariableDeclaration
  | DereferenceExpression
  | ReferenceExpression
  | ImportExpression
  | SpreadElement
  | YieldExpression
  | PackageDeclaration
export type Statement =
  | Noop
  | ExportStatement
  | IfStatement
  | SwitchStatement
  | ForStatement
  | WhileStatement
  | RangeStatement
  | LabeledStatement
  | ReturnStatement
  | BreakStatement
  | ContinueStatement
  | ThrowStatement
  | TryStatement
  | ExpressionStatement
  | ScopedStatement
  | Sequence
  | FunctionDefinition
  | ClassDefinition
  | VariableDeclaration
  | YieldExpression
  | PackageDeclaration
export type LVal = Identifier | MemberAccess
export type Type =
  | Identifier
  | PrimitiveType
  | ArrayType
  | PointerType
  | MapType
  | ScopedType
  | TupleType
  | ChanType
  | FuncType
  | DynamicType
  | VoidType
export type Conditional = IfStatement | SwitchStatement | ConditionalExpression
export type Loop = ForStatement | WhileStatement | RangeStatement
export type Scopable =
  | WhileStatement
  | RangeStatement
  | CatchClause
  | ScopedStatement
  | FunctionDefinition
  | ClassDefinition
export type Declaration =
  | FunctionDefinition
  | ClassDefinition
  | VariableDeclaration
  | PackageDeclaration

export interface Aliases {
  Standardized: Standardized
  Instruction: Instruction
  Expression: Expression
  Statement: Statement
  LVal: LVal
  Type: Type
  Conditional: Conditional
  Loop: Loop
  Scopable: Scopable
  Declaration: Declaration
}
