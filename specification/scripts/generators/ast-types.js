import t from "../../dist/index.js";
import stringifyValidator from "../utils/stringifyValidator.js";

export default function generateAstTypes() {
  let code = `// NOTE: This file is autogenerated. Do not modify.

export interface SourceLocation {
    start: {
        line: number;
        column: number;
    };
    end: {
        line: number;
        column: number;
    };
    sourcefile? : string | null;
}

interface BaseNode {
    type: Node['type'];
    loc : SourceLocation | undefined;
    _meta?: Record<string, unknown>;
}

export type Node = ${t.TYPES.filter(k => !t.FLIPPED_ALIAS_KEYS[k])
    .sort()
    .join(" | ")};\n\n`;

  // const deprecatedAlias = {};
  // for (const type in t.DEPRECATED_KEYS) {
  //   deprecatedAlias[t.DEPRECATED_KEYS[type]] = type;
  // }
  for (const type in t.NODE_FIELDS) {
    const fields = t.NODE_FIELDS[type];
    const comment = t.NODE_COMMENTS[type];
    const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);
    const struct = [];

    fieldNames.forEach(fieldName => {
      const field = fields[fieldName];
      const filedComment = t.NODE_FIELD_COMMENTS[type][fieldName];
      if (filedComment.trim() !== '') {
        struct.push(`/**${t.NODE_FIELD_COMMENTS[type][fieldName]}**/`)
      }
      // Future / annoying TODO:
      // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:
      // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,
      // - declare an alias type for valid keys, detect the case and reuse it here,
      // - declare a disjoint union with, for example, ObjectPropertyBase,
      //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty
      //   as "ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)"
      let typeAnnotation = stringifyValidator(field.validate, "");

      if (isNullable(field) && !hasDefault(field)) {
        typeAnnotation += " | null";
      }

      const alphaNumeric = /^\w+$/;
      const optional = field.optional ? "?" : "";

      if (t.isValidIdentifier(fieldName) || alphaNumeric.test(fieldName)) {
        struct.push(`${fieldName}${optional}: ${typeAnnotation};`);
      } else {
        struct.push(`"${fieldName}"${optional}: ${typeAnnotation};`);
      }
    });
    if (comment.trim() !== '') {
      code += `/**\n${comment}\n**/\n`
    }
    code += `export interface ${type} extends BaseNode {
  type: "${type}";
  ${struct.join("\n  ").trim()}
}\n\n`;

//     if (deprecatedAlias[type]) {
//       code += `/**
//  * @deprecated Use \`${type}\`
//  */
// export interface ${deprecatedAlias[type]} extends BaseNode {
//   type: "${deprecatedAlias[type]}";
//   ${struct.join("\n  ").trim()}
// }\n\n
// `;
//     }
  }

  for (const type in t.FLIPPED_ALIAS_KEYS) {
    const types = t.FLIPPED_ALIAS_KEYS[type];
    code += `export type ${type} = ${types
      .map(type => `${type}`)
      .join(" | ")};\n`;
  }
  code += "\n";

  code += "export interface Aliases {\n";
  for (const type in t.FLIPPED_ALIAS_KEYS) {
    code += `  ${type}: ${type};\n`;
  }
  code += "}\n\n";
  // code += `export type DeprecatedAliases = ${Object.keys(
  //   t.DEPRECATED_KEYS
  // ).join(" | ")}\n\n`;

  return code;
}

function hasDefault(field) {
  return field.default != null;
}

function isNullable(field) {
  return field.optional || hasDefault(field);
}

function sortFieldNames(fields, type) {
  return fields.sort((fieldA, fieldB) => {
    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
}

generateAstTypes();
